<!doctype html><html lang=ko-kr dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="React의 useMemo 훅을 활용한 렌더링 최적화와 객체 안정화 기법을 알아봅니다. 성능 문제 해결부터 실무 활용 사례까지 단계별로 이해하기 쉽게 설명합니다. "><title>useMemo 활용한 React 객체 안정화 & 리렌더링 최적화 기법</title><link rel=canonical href=https://ctrlcccv.github.io/code/2025-06-04-react-usememo/><link rel=stylesheet href=/scss/style.min.f8f2ffa38007b2836bfa74b6d37bb415044d35b7fd34320b4fc7ad572ba1c09c.css><meta property='og:title' content="useMemo 활용한 React 객체 안정화 & 리렌더링 최적화 기법\n"><meta property='og:description' content="React의 useMemo 훅을 활용한 렌더링 최적화와 객체 안정화 기법을 알아봅니다. 성능 문제 해결부터 실무 활용 사례까지 단계별로 이해하기 쉽게 설명합니다. "><meta property='og:url' content='https://ctrlcccv.github.io/code/2025-06-04-react-usememo/'><meta property='og:site_name' content='컨트롤 + CCCV'><meta property='og:type' content='article'><meta property='article:section' content='Code'><meta property='article:tag' content='React Hooks'><meta property='article:tag' content='useMemo'><meta property='article:tag' content='성능 최적화'><meta property='article:published_time' content='2025-06-04T00:00:00+00:00'><meta property='article:modified_time' content='2025-06-04T00:00:00+00:00'><meta property='og:image' content='https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-04-react-usememo.webp'><meta name=twitter:title content="useMemo 활용한 React 객체 안정화 & 리렌더링 최적화 기법\n"><meta name=twitter:description content="React의 useMemo 훅을 활용한 렌더링 최적화와 객체 안정화 기법을 알아봅니다. 성능 문제 해결부터 실무 활용 사례까지 단계별로 이해하기 쉽게 설명합니다. "><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-04-react-usememo.webp'><link rel="shortcut icon" href=/favicon.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-51LVT1KPFF"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-51LVT1KPFF")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8535540836842352" crossorigin=anonymous></script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","rit02y637k")</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"useMemo 활용한 React 객체 안정화 \u0026 리렌더링 최적화 기법\n","datePublished":"2025-06-04T00:00:00Z","dateModified":"2025-06-04T00:00:00Z","author":{"@type":"Person","name":"컨트롤 + CCCV"}}</script><link rel=alternate title="useMemo 활용한 React 객체 안정화 & 리렌더링 최적화 기법" href=https://ctrlcccv.github.io/code/2025-06-04-react-usememo/ hreflang=ko><link rel=alternate title="React useMemo Tutorial: Optimize Render Performance" href=https://ctrlcccv.github.io/code-en/2025-06-05-react-usememo/ hreflang=en></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><div class=site-meta><h1 class=site-name><a href=/>컨트롤 + CCCV</a></h1><h2 class=site-description>웹 퍼블리싱 정보 블로그</h2></div></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/contact/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Contact</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>다크 모드</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#usememo-기본-이해하기>useMemo 기본 이해하기</a><ol><li><a href=#usememo란>useMemo란?</a></li><li><a href=#기본-구조>기본 구조</a></li><li><a href=#작동-원리>작동 원리</a></li></ol></li><li><a href=#객체-안정화와-불필요한-리렌더링-방지>객체 안정화와 불필요한 리렌더링 방지</a></li><li><a href=#실무-활용-사례-데이터-필터링-및-정렬>실무 활용 사례: 데이터 필터링 및 정렬</a></li><li><a href=#주의사항-및-모범-사례>주의사항 및 모범 사례</a></li><li><a href=#결론>결론</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/code/2025-06-04-react-usememo/><img src=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-04-react-usememo.webp loading=lazy alt="Featured image of post useMemo 활용한 React 객체 안정화 & 리렌더링 최적화 기법
"></a></div><div class=article-details><header class=article-category><a href=/categories/react/>React</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/code/2025-06-04-react-usememo/>useMemo 활용한 React 객체 안정화 & 리렌더링 최적화 기법</a></h2><h3 class=article-subtitle>React의 useMemo 훅을 활용한 렌더링 최적화와 객체 안정화 기법을 알아봅니다. 성능 문제 해결부터 실무 활용 사례까지 단계별로 이해하기 쉽게 설명합니다.</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2025-06-04T00:00:00Z>6월 04, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>5 분 정도</time></div></footer></div></header><section class=article-content><p>React 앱에서 같은 계산을 계속 반복해서 수행하느라 답답했던 적이 있으신가요?</p><p>웹 개발을 하다 보면 복잡한 계산이나 데이터 처리가 매 렌더링마다 반복되어 성능이 떨어지는 경우가 많습니다. 특히 대량의 데이터를 필터링하거나 정렬할 때는 화면이 버벅거리고 앱이 느려지는 문제가 발생합니다. 이런 상황에서 React의 useMemo 훅이 효과적인 해결책이 될 수 있습니다.</p><br><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8535540836842352 data-ad-slot=2974559225></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><br><h2 id=usememo-기본-이해하기>useMemo 기본 이해하기</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kr>import</span> <span class=nx>React</span><span class=p>,</span> <span class=p>{</span> <span class=nx>useState</span><span class=p>,</span> <span class=nx>useMemo</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;react&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>계산컴포넌트</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>숫자A</span><span class=p>,</span> <span class=nx>숫자A설정</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>숫자B</span><span class=p>,</span> <span class=nx>숫자B설정</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 비용이 많이 드는 계산을 useMemo로 최적화
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>합계</span> <span class=o>=</span> <span class=nx>useMemo</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 첫 번째 인자: 계산 함수 - 메모이제이션할 값을 계산하고 반환합니다
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;합계 다시 계산중...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>숫자A</span> <span class=o>+</span> <span class=nx>숫자B</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 두 번째 인자: 의존성 배열 - 이 값들이 변경될 때만 위의 계산 함수가 다시 실행됩니다
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>[</span><span class=nx>숫자A</span><span class=p>,</span> <span class=nx>숫자B</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span> 
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>input</span> 
</span></span><span class=line><span class=cl>        <span class=na>type</span><span class=o>=</span><span class=s>&#34;number&#34;</span> 
</span></span><span class=line><span class=cl>        <span class=na>value</span><span class=o>=</span><span class=p>{</span><span class=nx>숫자A</span><span class=p>}</span> 
</span></span><span class=line><span class=cl>        <span class=na>onChange</span><span class=o>=</span><span class=p>{(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>숫자A설정</span><span class=p>(</span><span class=nb>Number</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>value</span><span class=p>))}</span> 
</span></span><span class=line><span class=cl>      <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>input</span> 
</span></span><span class=line><span class=cl>        <span class=na>type</span><span class=o>=</span><span class=s>&#34;number&#34;</span> 
</span></span><span class=line><span class=cl>        <span class=na>value</span><span class=o>=</span><span class=p>{</span><span class=nx>숫자B</span><span class=p>}</span> 
</span></span><span class=line><span class=cl>        <span class=na>onChange</span><span class=o>=</span><span class=p>{(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>숫자B설정</span><span class=p>(</span><span class=nb>Number</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>value</span><span class=p>))}</span> 
</span></span><span class=line><span class=cl>      <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span><span class=nx>합계</span><span class=o>:</span> <span class=p>{</span><span class=nx>합계</span><span class=p>}&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=usememo란>useMemo란?</h3><p>useMemo는 쉽게 말해 &ldquo;이전에 계산한 값을 기억해두는 상자"입니다. 자주 시키는 음식을 기억해뒀다가 같은 메뉴를 주문할 때 바로 제공하는 것처럼, useMemo도 이전 계산 결과를 재사용합니다.</p><br><h3 id=기본-구조>기본 구조</h3><p>useMemo 훅은 두 가지 필수 인자를 받아 동작합니다:</p><ol><li><strong>계산 함수</strong>: 메모이제이션(재사용)할 값을 만들어내는 함수입니다. 이 함수의 결과값이 저장되고 필요할 때 재사용됩니다.</li><li><strong>의존성 배열</strong>: 이 배열에 포함된 값들이 변경될 때만 계산 함수가 다시 실행됩니다. 배열 내 값들이 이전과 동일하다면 계산을 건너뛰고 저장된 결과를 그대로 사용합니다.</li></ol><br><h3 id=작동-원리>작동 원리</h3><p>위 예제에서 <code>합계</code> 값은 useMemo로 메모이제이션됩니다. 컴포넌트가 다시 그려져도 <code>숫자A</code>와 <code>숫자B</code>가 변하지 않았다면, 이전에 계산된 합계 값을 그대로 사용합니다. 이렇게 하면 불필요한 계산을 줄이고 앱 성능을 높일 수 있습니다.</p><br><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8535540836842352 data-ad-slot=2974559225></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><br><h2 id=객체-안정화와-불필요한-리렌더링-방지>객체 안정화와 불필요한 리렌더링 방지</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kd>function</span> <span class=nx>ParentComponent</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>user</span><span class=p>,</span> <span class=nx>setUser</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>({</span> <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;John&#39;</span><span class=p>,</span> <span class=nx>age</span><span class=o>:</span> <span class=mi>30</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 안정화되지 않은 객체 - 매 렌더링마다 새 객체 생성됨
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>userInfo</span> <span class=o>=</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=nx>name</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>details</span><span class=o>:</span> <span class=sb>`</span><span class=si>${</span><span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=si>}</span><span class=sb> is </span><span class=si>${</span><span class=nx>user</span><span class=p>.</span><span class=nx>age</span><span class=si>}</span><span class=sb> years old`</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>role</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>age</span> <span class=o>&gt;=</span> <span class=mi>19</span> <span class=o>?</span> <span class=s1>&#39;Adult&#39;</span> <span class=o>:</span> <span class=s1>&#39;Minor&#39;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span> <span class=c1>// 매번 새로운 메모리 주소를 가진 객체 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=c1>// useMemo로 객체 안정화 - user.name이나 user.age가 변경될 때만 새 객체 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>memoizedUserInfo</span> <span class=o>=</span> <span class=nx>useMemo</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>name</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>details</span><span class=o>:</span> <span class=sb>`</span><span class=si>${</span><span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=si>}</span><span class=sb>님은 </span><span class=si>${</span><span class=nx>user</span><span class=p>.</span><span class=nx>age</span><span class=si>}</span><span class=sb>세입니다`</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>role</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>age</span> <span class=o>&gt;=</span> <span class=mi>19</span> <span class=o>?</span> <span class=s1>&#39;성인&#39;</span> <span class=o>:</span> <span class=s1>&#39;미성년자&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[</span><span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>user</span><span class=p>.</span><span class=nx>age</span><span class=p>]);</span> <span class=c1>// 의존성 배열 - 이 값들이 변경될 때만 재계산
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=cm>/* 매 렌더링마다 자식이 리렌더링됨 (비효율적) */</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>ChildComponent</span> <span class=na>userInfo</span><span class=o>=</span><span class=p>{</span><span class=nx>userInfo</span><span class=p>}</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=cm>/* user 정보가 변경될 때만 자식이 리렌더링됨 (효율적) */</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>OptimizedChild</span> <span class=na>userInfo</span><span class=o>=</span><span class=p>{</span><span class=nx>memoizedUserInfo</span><span class=p>}</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;/&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// React.memo로 최적화된 자식 컴포넌트 - props가 변경될 때만 리렌더링
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>OptimizedChild</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>memo</span><span class=p>(</span><span class=kd>function</span><span class=p>({</span> <span class=nx>userInfo</span> <span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;자식 컴포넌트 렌더링&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;{</span><span class=nx>userInfo</span><span class=p>.</span><span class=nx>details</span><span class=p>}&lt;/</span><span class=nt>div</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>React에서 컴포넌트가 다시 그려질 때마다 내부에서 만든 객체는 새로 생성됩니다. 자바스크립트에서 객체는 참조 타입이므로, 내용이 같아도 다른 메모리 주소를 가진 새 객체로 인식합니다. 이로 인해 React.memo로 최적화한 자식 컴포넌트도 불필요하게 리렌더링됩니다.</p><p>useMemo를 사용하면 의존성 배열의 값이 바뀔 때만 새 객체를 만들어 불필요한 자식 컴포넌트 리렌더링을 방지할 수 있습니다.</p><br><h2 id=실무-활용-사례-데이터-필터링-및-정렬>실무 활용 사례: 데이터 필터링 및 정렬</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kd>function</span> <span class=nx>ProductList</span><span class=p>({</span> <span class=nx>products</span><span class=p>,</span> <span class=nx>searchTerm</span><span class=p>,</span> <span class=nx>category</span><span class=p>,</span> <span class=nx>sortBy</span> <span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 필터링 및 정렬된 상품 목록을 계산하고 메모이제이션
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>filteredProducts</span> <span class=o>=</span> <span class=nx>useMemo</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;상품 필터링 중...&#34;</span><span class=p>);</span> <span class=c1>// 성능 측정용 로그
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// 1단계: 검색어와 카테고리로 필터링
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>let</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>products</span><span class=p>.</span><span class=nx>filter</span><span class=p>(</span><span class=nx>product</span> <span class=p>=&gt;</span> 
</span></span><span class=line><span class=cl>      <span class=nx>product</span><span class=p>.</span><span class=nx>name</span><span class=p>.</span><span class=nx>toLowerCase</span><span class=p>().</span><span class=nx>includes</span><span class=p>(</span><span class=nx>searchTerm</span><span class=p>.</span><span class=nx>toLowerCase</span><span class=p>())</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nx>category</span> <span class=o>===</span> <span class=s1>&#39;all&#39;</span> <span class=o>||</span> <span class=nx>product</span><span class=p>.</span><span class=nx>category</span> <span class=o>===</span> <span class=nx>category</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 2단계: 정렬 기준에 따라 정렬
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>sortBy</span> <span class=o>===</span> <span class=s1>&#39;price-asc&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>result</span> <span class=o>=</span> <span class=nx>result</span><span class=p>.</span><span class=nx>sort</span><span class=p>((</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>a</span><span class=p>.</span><span class=nx>price</span> <span class=o>-</span> <span class=nx>b</span><span class=p>.</span><span class=nx>price</span><span class=p>);</span> <span class=c1>// 가격 오름차순
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>sortBy</span> <span class=o>===</span> <span class=s1>&#39;price-desc&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>result</span> <span class=o>=</span> <span class=nx>result</span><span class=p>.</span><span class=nx>sort</span><span class=p>((</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>price</span> <span class=o>-</span> <span class=nx>a</span><span class=p>.</span><span class=nx>price</span><span class=p>);</span> <span class=c1>// 가격 내림차순
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>sortBy</span> <span class=o>===</span> <span class=s1>&#39;name&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>result</span> <span class=o>=</span> <span class=nx>result</span><span class=p>.</span><span class=nx>sort</span><span class=p>((</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>a</span><span class=p>.</span><span class=nx>name</span><span class=p>.</span><span class=nx>localeCompare</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>name</span><span class=p>));</span> <span class=c1>// 이름순
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[</span><span class=nx>products</span><span class=p>,</span> <span class=nx>searchTerm</span><span class=p>,</span> <span class=nx>category</span><span class=p>,</span> <span class=nx>sortBy</span><span class=p>]);</span> <span class=c1>// 이 값들이 변경될 때만 재계산
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;{</span><span class=nx>filteredProducts</span><span class=p>.</span><span class=nx>length</span><span class=p>}</span><span class=nx>개</span> <span class=nx>상품</span> <span class=nx>찾음</span><span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=nx>filteredProducts</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=nx>product</span> <span class=p>=&gt;</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>          <span class=p>&lt;</span><span class=nt>li</span> <span class=na>key</span><span class=o>=</span><span class=p>{</span><span class=nx>product</span><span class=p>.</span><span class=nx>id</span><span class=p>}&gt;{</span><span class=nx>product</span><span class=p>.</span><span class=nx>name</span><span class=p>}</span> <span class=o>-</span> <span class=p>{</span><span class=nx>product</span><span class=p>.</span><span class=nx>price</span><span class=p>}</span><span class=nx>원</span><span class=p>&lt;/</span><span class=nt>li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>))}</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;/</span><span class=nt>ul</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>실제 적용 시나리오:</strong></p><ul><li><strong>쇼핑몰</strong>: 사용자가 검색어를 입력하거나 필터/정렬 옵션을 변경할 때마다 상품 목록을 효율적으로 업데이트</li><li><strong>대시보드</strong>: 대량의 데이터를 필터링하고 가공해야 하는 비즈니스 인텔리전스 도구</li><li><strong>관리자 패널</strong>: 사용자/주문/콘텐츠 목록의 검색 및 필터링 기능</li></ul><p><strong>성능 개선 효과:</strong></p><ol><li>검색어, 카테고리, 정렬 옵션이 변경될 때만 데이터 처리 로직이 실행됩니다.</li><li>입력 필드에 타이핑하거나 다른 UI 상호작용 시에도 화면 응답성이 유지됩니다.</li><li>특히 대량 데이터(수백~수천 항목) 처리 시 효과가 극대화됩니다.</li></ol><p>이 패턴은 실무에서 가장 많이 활용되는 useMemo 사용법입니다. 사용자 입력에 따라 데이터를 실시간으로 필터링하고 정렬할 때 계산 비용이 크게 들 수 있는데, useMemo를 사용하면 필요한 경우에만 재계산하여 앱의 반응성을 유지할 수 있습니다.</p><br><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8535540836842352 data-ad-slot=2974559225></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><br><h2 id=주의사항-및-모범-사례>주의사항 및 모범 사례</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kd>function</span> <span class=nx>WarningExampleComponent</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 1. 간단한 계산에는 불필요 (과도한 사용 예시)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>unnecessaryExample</span> <span class=o>=</span> <span class=nx>useMemo</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>count</span> <span class=o>+</span> <span class=mi>10</span><span class=p>,</span> <span class=p>[</span><span class=nx>count</span><span class=p>]);</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 주의: 이런 간단한 계산은 useMemo 오버헤드가 더 클 수 있음
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=c1>// 2. 의존성 배열 관리 (잘못된 사용)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>wrongDependencies</span> <span class=o>=</span> <span class=nx>useMemo</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>calculateWithCount</span><span class=p>(</span><span class=nx>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[]);</span> <span class=c1>// 버그 발생: count가 의존성 배열에 없어 값이 갱신되지 않음
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=c1>// 3. 올바른 사용 예시
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>correctExample</span> <span class=o>=</span> <span class=nx>useMemo</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 정말 무거운 계산만 여기에 넣기
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>expensiveCalculation</span><span class=p>(</span><span class=nx>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[</span><span class=nx>count</span><span class=p>]);</span> <span class=c1>// 올바른 의존성: 원시값 직접 사용
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>button</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=nx>setCount</span><span class=p>(</span><span class=nx>prev</span> <span class=p>=&gt;</span> <span class=nx>prev</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)}&gt;</span><span class=nx>증가</span><span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span><span class=nx>현재</span> <span class=nx>카운트</span><span class=o>:</span> <span class=p>{</span><span class=nx>count</span><span class=p>}&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>useMemo를 사용할 때 주의할 점:</p><ul><li><strong>성능 측정 먼저</strong>: 실제 성능 문제가 있는 부분을 먼저 찾아서 적용하세요.</li><li><strong>간단한 계산에는 사용하지 않기</strong>: 메모이제이션 비용이 계산 자체보다 클 수 있습니다.</li><li><strong>의존성 배열 정확히 관리하기</strong>: 계산에 사용되는 모든 값은 의존성 배열에 꼭 포함해야 합니다.</li><li><strong>객체와 배열 주의하기</strong>: 의존성 배열에 객체나 배열 대신 원시 타입 값(숫자, 문자열, 불리언)을 사용하세요.</li></ul><br><h2 id=결론>결론</h2><p>React의 useMemo 훅은 복잡한 계산을 최적화하고 객체의 참조 안정성을 유지하는 강력한 도구입니다. 모든 계산에 적용하기보다는 실제 성능 병목이 있는 부분을 찾아 적용하는 것이 좋습니다. 복잡한 데이터 처리, 객체 안정화, 비용이 많이 드는 계산에 집중적으로 사용하면 최상의 결과를 얻을 수 있습니다.</p><p>여러분은 프로젝트에서 useMemo를 어떻게 활용하고 계신가요? 혹시 메모이제이션으로 해결한 성능 문제가 있으신가요? 댓글로 경험을 공유해주세요!</p><br></section><footer class=article-footer><section class=article-tags><a href=/tags/react-hooks/>React Hooks</a>
<a href=/tags/usememo/>UseMemo</a>
<a href=/tags/%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/>성능 최적화</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>관련 글</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/code/2025-06-10-usememo-usecallback/><div class=article-image><img src=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-10-usememo-usecallback.webp loading=lazy data-key=2025-06-10-usememo-usecallback data-hash=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-10-usememo-usecallback.webp></div><div class=article-details><h2 class=article-title>React useMemo vs useCallback 차이점 쉽게 이해하기</h2></div></a></article><article class=has-image><a href=/code/2025-06-06-react-usecallback/><div class=article-image><img src=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-06-react-usecallback.webp loading=lazy data-key=2025-06-06-react-usecallback data-hash=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-06-react-usecallback.webp></div><div class=article-details><h2 class=article-title>React useCallback으로 불필요한 리렌더링 방지하기</h2></div></a></article><article class=has-image><a href=/code-en/2025-06-05-react-usememo/><div class=article-image><img src=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-05-react-usememo-en.webp loading=lazy data-key=2025-06-05-react-usememo data-hash=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-05-react-usememo-en.webp></div><div class=article-details><h2 class=article-title>React useMemo Tutorial: Optimize Render Performance</h2></div></a></article><article class=has-image><a href=/code-en/2025-06-13-usememo-usecallback/><div class=article-image><img src=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-10-usememo-usecallback.webp loading=lazy data-key=2025-06-13-usememo-usecallback data-hash=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-10-usememo-usecallback.webp></div><div class=article-details><h2 class=article-title>React useMemo vs useCallback: 5 Key Differences Every Developer Must Know</h2></div></a></article><article class=has-image><a href=/code-en/2025-06-11-react-usecallback/><div class=article-image><img src=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-11-react-usecallback-en.webp loading=lazy data-key=2025-06-11-react-usecallback data-hash=https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2025-06-11-react-usecallback-en.webp></div><div class=article-details><h2 class=article-title>Stop React Re-renders with useCallback Hook</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=ctrlcccv/ctrlcccv.github.io issue-term=url label=comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2025 컨트롤 + CCCV</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>
---
title: 부동 소수점 연산의 정확도 문제와 해결 방안
description: >  
    부동 소수점 연산의 정확도 문제를 다루며, 이진수 변환, 부동 소수점 표현의 한계와 같은 원인을 설명합니다. 또한, 정수 연산 사용, 고정 소수점 사용, 높은 정밀도 라이브러리 사용, 에러 보정 기술 등 다양한 해결 방안을 제시합니다.
slug: 2023-12-06-float
date: 2023-12-06 00:00:00+0000
lastmod: 2023-12-06 00:00:00+0000
image: https://media.githubusercontent.com/media/ctrlcccv/ctrlcccv.github.io/master/assets/img/post/2023-12-06-float.webp

categories:
    - Python
tags:

---
컴퓨터 프로그래밍에서 부동 소수점 연산의 정확도 문제는 오래된 도전 과제입니다. 특히, 1.1 + 0.1 == 1.2가 False로 평가되는 현상과 같은 예는 이 문제를 잘 보여줍니다. 이 글에서는 이 현상의 원인과 가능한 해결 방법을 탐구하겠습니다.  

<br>

<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8535540836842352"
     data-ad-slot="2974559225"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


<br>

## 부동 소수점 연산의 정확도 문제의 원인
부동 소수점 연산의 정확도 문제를 이해하기 위해서는 먼저 컴퓨터가 실수를 어떻게 표현하고 계산하는지 이해해야 합니다.

* **이진수로의 변환**  
컴퓨터는 모든 데이터를 이진수(0과 1)로 처리합니다. 이 때문에, 컴퓨터에서는 10진수 실수를 정확하게 표현하기 어렵습니다. 예를 들어, 10진수 1.1과 0.1은 이진수로 완벽하게 변환되지 않습니다. 10진수 1.1은 이진수로 변환하면 무한한 이진 소수가 됩니다. 컴퓨터는 이를 저장하기 위해 이진 소수를 끊어야 하는데, 이 과정에서 오차가 발생합니다. 예를 들어, 1.1은 이진수로 대략 1.00011001100110011001101과 같이 근사됩니다.

* **부동 소수점 표현**
  * 컴퓨터는 부동 소수점 표준인 IEEE 754를 사용해 실수를 표현합니다. 이 표준에 따라, 실수는 다음과 같이 세 부분으로 나뉩니다.
  * 부호 비트(Sign bit) : 숫자가 양수인지 음수인지 나타냅니다.
  * 지수(Exponent) : 소수점의 위치를 조정합니다.
  * 가수(Mantissa 또는 Fraction): 실제 숫자 데이터를 나타냅니다.

* **정밀도 한계**  
이 표현 방식은 메모리 공간의 제한 때문에 가수 부분에 숫자를 저장할 때 일정한 비트만 사용할 수 있습니다. 예를 들어, 64비트 부동 소수점 표현(더블 프리시전)에서 가수 부분은 52비트로 제한됩니다. 이로 인해 숫자를 정확하게 표현하는 데 한계가 생깁니다.

* **연산 과정의 오차**  
부동 소수점 연산에서는 이러한 근삿값을 사용합니다. 예를 들어, 1.1 + 0.1을 계산할 때, 각 숫자의 이진수 근삿값을 더합니다. 이 과정에서 미세한 오차가 누적되어, 최종 결과가 1.2와 정확히 일치하지 않을 수 있습니다. 이러한 오차는 특히 숫자가 많거나 복잡한 연산에서 더욱 눈에 띄게 됩니다.  

<br>

<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8535540836842352"
     data-ad-slot="2974559225"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


<br>

## 해결 방법

* **정수 연산 사용**
  * 원리 : 실수 대신 정수를 사용하여 연산을 수행합니다. 예를 들어, 소수점 이하 값을 필요한 자릿수만큼 확대하여 정수로 변환한 후 연산을 수행합니다.
  * 장점 : 정수 연산은 부동 소수점 연산보다 오차가 없고 더 예측 가능합니다.
  * 적용 사례 : 금융 계산에서 소수점 이하의 금액을 정확히 계산해야 할 때 자주 사용됩니다.

* **고정 소수점 사용**
  * 원리 : 소수점의 위치를 고정시켜, 모든 연산에서 동일한 자릿수를 유지합니다.
  * 장점 : 부동 소수점보다 연산 결과의 예측 가능성이 높아집니다. 또한, 특정 범위의 값에 대해 더 정확한 연산을 보장합니다.
  * 주의점 : 사용 가능한 숫자의 범위가 제한됩니다.

* **높은 정밀도 라이브러리 사용**
  * 원리 : 표준 부동 소수점 연산보다 더 많은 비트를 사용하여 실수를 표현하고 연산하는 라이브러리를 사용합니다.
  * 장점 : 매우 높은 정밀도의 연산이 가능합니다.
  * 적용 사례 : 과학적 계산, 큰 수의 정밀한 연산, 복잡한 수학적 모델링 등에 사용됩니다.

* **에러 보정 기술**
  * 원리 : 연산 과정에서 발생할 수 있는 오차를 최소화하기 위한 알고리즘을 사용합니다.
  * 예시 : Kahan summation 알고리즘은 누적되는 오차를 추적하고 보정하여 더 정확한 합계를 제공합니다.
  * 적용 사례 : 다수의 작은 값들을 더할 때 유용합니다.

* **상황에 맞는 데이터 타입 선택**
  * 원리 : 특정 언어나 환경에서 제공하는 다양한 데이터 타입 중에서, 상황에 가장 적합한 것을 선택합니다.
  * 장점 : 언어나 환경이 제공하는 최적화된 연산 방법을 활용할 수 있습니다.
  * 주의점 : 모든 언어나 환경이 다양한 데이터 타입을 지원하지는 않습니다.  
<br>

## 결론
부동 소수점 연산의 정확도 문제는 복잡하지만, 상황과 요구사항에 맞는 여러 해결 방안을 통해 대응할 수 있습니다. 정확한 연산이 필요한 경우, 고정 소수점 사용, 높은 정밀도 라이브러리의 사용, 에러 보정 기술 등을 고려해야 합니다. 이러한 방법들은 각각의 장단점을 가지고 있으며, 특정 상황에 가장 적합한 방법을 선택하는 것이 중요합니다.  
<br>

<div class="btn_wrap">
    <a href="https://docs.python.org/ko/3/tutorial/floatingpoint.html">[참고문서] 부동 소수점 산술 : 문제점 및 한계</a>
</div>





